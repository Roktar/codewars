# Most Frequent Weekdays - 20. 06. 03

이 문제는 입력값을 출력값의 형태로 만들어 반환한다.

- 기본 함수 (1)
  - mostFrequentDays(year: 정수)
    - 결과값 출력
- 기본적으로 주어지는 객체(0)
- 문제에서 요구하는 다른 함수(0)
- 추가함수(0)
- 추가클래스(0)
  - 구성함수(0)
- 추가객체(0)
- 추가변수(0)

- 입력 or 호출
  <pre> mostFrequentDays(1984) </pre>
 
- 출력
  <pre> ['Monday', 'Sunday'] </pre>

> 문제
  - 이 문제는 주어진 연도에서 가장 빈번하게 나타나는 요일을 구한다.
  - 자바스크립트에서 요일을 나타내는 getDay 함수는 0~6의 수를 반환하는데 이는 일요일~토요일을 나타낸다.
  - 문제에서 요구하는 정렬은 일요일~토요일이 아닌 월요일~일요일 순이다.

> 풀이 과정 및 결과
<pre>
해당 문제는 1개 결과는 출력했으나 2개 결과를 출력하는 것은 도저히 모르겠어서 검색하여 참고하였다.
(참고링크: https://medium.com/@ko.liu.learn/%E7%B7%B4%E5%8A%9F-codewars-most-frequent-weekdays-da4b33430c59)

단순하게 생각하면 가장 빈번한 날은 각 년도의 1월 1일에 해당하는 요일이다. 가장 먼저 등장하였으니 가장 많이 나올 것이라 생각하였다. 그래서 주어진 연도의 1월 1일의 요일을 먼저 구하였다. 
(구한 요일(getDay 함수)에서 -1을 한 이유는 문제에서 요구하는 정렬순서가 원인)
(월요일인 경우, getDay 함수로 가져올 시 1이나 문제에서 사용한 배열은 월~일 이므로 월요일의 인덱스는 0이기때문에 -1을 하였고, 기존 일요일인 경우 0에서 -1을 더하면 -1이 되고 현재 배열에서 일요일의 인덱스는 6이므로 6으로 세팅)

추가로 빈번한 요일은 어떤 기준인지 모르겠었으나 문제풀이 도중 생각하지 못했던 것은 윤년으로, 윤년을 포함하여 시도하다보니 윤년인 경우에는 빈번한 요일이 한 개 더 발생하는 것을 찾을 수 있었다.
윤년일 때 현재 요일에서 하루를 더 더해봤었으나 답이 아니어서 그냥 냅둬봤더니 테스트케이스를 통과하였다. 
- 확실치는 않지만 일~토 순이었을 경우, 코드는 [day , day+1] 처럼 연속된 요일에 윤년인 경우에는 하루를 더한 요일이 추가되는 것 같다. (앞이 지금의 day-1, 뒤가 윤년인 지금의 day)
</pre>

>변경 이력
<pre>
</pre>