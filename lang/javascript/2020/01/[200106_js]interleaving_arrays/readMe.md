# Interleaving Arrays- 20. 01. 06

이 문제는 입력값을 출력값의 형태로 만들어 반환한다.

- 기본 함수 (1)
  - interleave()
    - 결과값 출력
- 기본적으로 주어지는 객체(0)
- 문제에서 요구하는 다른 함수(0)
- 추가함수(0)
- 추가클래스(0)
- 추가객체(0)
- 추가변수(0)

- 입력 or 호출
  <pre> interleave([1, 2, 3], [4, 5])</pre>
 
- 출력
  <pre> [1, 4, 2, 5, 3, null] </pre>

> 문제
  - 이 문제는 주어진 배열을 결과형태로 만든다.
  - 입력값에 주어진 배열들의 특정 인덱스를 연속으로 붙여서 만든 새로운 배열을 반환한다.

> 풀이 과정 및 결과
<pre>
해당 문제는 입력값에 주어진 배열들의 특정 인덱스에 있는 값들을 연속으로 붙여 새로운 1차원배열을 반환한다.
입력값은 함수에서 명시적으로 받아오는 아규먼트가 없으므로 내장 객체인 arguments에서 꺼내온다.
만약 입력값이 2개이고 각 배열은 [1, 2, 3], [4, 5] 인 경우, 다음과 같은 순서로 결과값을 만든다.
1) 먼저 모든 배열의 크기를 맞춰야한다. 따라서 입력값 중 가장 큰 크기의 값을 구한다. 이 크기는 각 배열당 반복횟수가 된다.
2) 반복문을 돌며 값을 하나씩 꺼낸다.
  - 첫 번째 반복문에서는 1, 4를 꺼낸다.(각 배열의 0번 인덱스에 있는 값) : [1, 4]
  - 두 번째 반복문에서는 2, 5를 꺼낸다.(각 배열의 1번 인덱스에 있는 값) : [1, 4, 2, 5]
  - 세 번째 반복문에서는 3을 꺼낸다.(각 배열의 2번 인덱스에 있는 값)
    - 두 번째 배열의 크기는 2로 2번 인덱스에 해당하는 값이 없다.(undefined)
    - 이 경우에는 null을 넣어 맞춘다. : [1, 4, 2, 5, 3, null]
즉, 결과배열은 [최대크기*입력값배열] 의 크기를 갖는다.
* 9 ~ 12번 라인은 result.push(arr[j][i] || null); 로 사용하려했으나, 해당 인덱스에 있는 값이 0인 경우 제대로 값이 들어가지 않아 (0 대신 null이 들어감) if문으로 분리했다. (0과 undefined 둘 다 falsy value여서 옆에 있는 null이 대신 추가됨)
</pre>

>변경 이력
