# Paul Cipher & Kevin Arnold - 19. 05. 05

이 문제는 입력값을 출력값의 형태로 만들어 반환한다.

- 기본 함수 (2)
  - encode(input:문자열)
    - 해당 문자열을 지정된 형식으로 암호화하여 반환
  - decode(input:문자열)
    - encode된 해당 문자열을 원래대로 복호화하여 반환
- 문제에서 요구하는 다른 함수(0)
- 추가함수(1)
  - getConvertTable()
    - 특정 문자의 아스키코드값과 아스키코드값에 대응하는 문자를 편하게 얻기위해 객체를 만든 후 그 객체를 반환하는 함수

- 입력
  <pre> 
      encode 함수 : "   The quick brown fox jumps over the lazy dog. "
      decode 함수 : " TBM VLDLN mTGLK TUM HEHCI HKAW LBM QMAY CSV. "
  </pre>
 
- 출력
  <pre> 
      encode 함수를 거쳐 나온 decode : " TBM VLDLN mTGLK TUM HEHCI HKAW LBM QMAY CSV. "
      decode 함수를 거쳐 나온 plain text : "   The quick brown fox jumps over the lazy dog. "
  </pre>

> 문제
  - 이 문제는 암호화와 복호화 2개를 구현한다.
  - 각 대문자는 다음의 값을 사용한다.
    - A : 1
    - B : 2
    - C : 3
    - ...
    - Y : 25
    - Z : 26
  - 암호화
    - 암호화 시 첫 문자는 암호화하지않고 그대로 넣는다.
      - 단, 암호화 대상 문자는 [A-Z] 사이의 대문자이며, 그 외의 문자(문자화된 숫자, 공백, 특수문자 등)은 암호화하지않고 그대로 넣는다.
    - 두 번째 문자부터는 다음 과정을 거친다.
      - 이전 텍스트의 값을 사용한다.
      - 입력이 "HE1LO"일 때, 첫 문자 H는 그대로 넣었다. 이 H를 사용하여 두 번째 문자를 구한다.
      - H는 알파벳 중 8번째에 있는 문자이므로 8의 값을 가지며 두 번째 문자 E는 5번째에 있는 문자이므로 5의 값을 가진다.
        - 즉, 해당 자리의 암호문은 8 + 5 = 13, 13번째 자리에 있는 M으로 암호화된다.
        - 암호화 : [H, M]
      - 1은 알파벳 대문자가 아니기때문에 그대로 반영한다.
        - 암호화 : [H, M, 1]
      - L은 알파벳 중 12번째 위치에 있는 문자이므로 12의 값을 갖는다.
        - 이전값은 1이나, 알파벳 대문자가 아닌 경우 이전문자로 인정하지않는다. 따라서 그 앞에 있는 문자인 암호화전 값인 E(5)가 이전값이 된다.
        - 즉, 해당 자리의 암호문은 12 + 5 = 17, 17번째 자리에 있는 Q로 암호화된다.
        - 암호화 : [H, M, 1, Q]
      - O는 알파벳 중 15번째에 있는 문자이므로 15의 값을 갖는다.
        - 암호화하지않은 이전값 L은 12번째 자리에 있으므로 12의 값을 갖는다.
        - 15 + 12 = 27, 단 대문자는 26자기때문에 26으로 나눠 나머지인 1을 암호값으로 사용한다.
        - 즉, 해당 자리의 암호문은 (15+12)%26 = 1, 1번째 자리에 있는 A로 암호화된다.
      - 따라서 "HM1QA"로 암호화된다.
  - 복호화 : 암호화했던 값을 원래대로 되돌린다.
    - 암호화와 마찬가지로 첫번째 문자는 암호화하지않는다.
    - 복호화 또한 이전 값을 사용한다.
      - 암호화시와 동일하게 암호화하지않은 이전값을 사용한다.
    - "HM1QA"가 암호문일 때 다음 과정을 거쳐 복호화한다.
      - 복호화시 값을 구할 때 다음 식을 사용한다.      
        - (([현재문자값]+26)-[이전문자값])%26 
      - 첫번째 문자 H는 암호화 및 복호화 대상이 아니기때문에 그대로 넘어간다.
        - 복호화 : [H]
      - 두번째 문자 M은 다음 과정을 거쳐 복호화한다.
        - 13번째 문자였기때문에 13의 값을 이용한다.
        - ((13+26)-8)%26 = 5, 즉 5번째 위치에 있는 'E'로 복호화된다.
          - 이전문자인 'H'는 8번째 위치에 있기때문에 8의 값을 가진다.
      - 세번째 문자인 1은 암호화 및 복호화 대상이 아니기때문에 그대로 넘어간다.
      - 네번째 문자인 Q는 다음 과정을 거쳐 복호화한다.
        - 1은 알파벳대문자가 아니기때문에 이전값으로 사용하지 않는다. 대신 그 앞에서 구했던 복호화값인 'E'를 사용한다. (암호화값인 'M'을 사용하는 것이 아니다.)
        - ((17+26)-5)%26 = 12, 즉 12번째 위치에 있는 'L'로 복호화된다.
      - 마지막 문자인 A는 다음 과정을 거쳐 복호화한다.
        - ((1+26)-12)%26 = 15, 즉 15번째 위치에 있는 'O'로 복호화된다.
      - 위 과정을 통해 암호화하기 전 평문이었던 "HE1LO"를 얻을 수 있다.


> 풀이
  - 공통
    - 입력값으로 null이 들어올 수 있으므로 해당 null에 대한 처리를 먼저 진행한다.
    - 입력값으로 소문자값이 들어올 수 있으므로 해당 소문자를 대문자로 바꾼다.
    - 가장 앞에 있는 대문자는 암호화대상이 아니기때문에 별도로 처리한다.(line 10-12, 40-42)
      - 단, '1234D'나 '    3A'처럼 대문자가 처음이 아닌 중간에 껴있을 수 있기때문에 앞의 문자를 전부 포함하여 대문자 하나만 추출한다. (line 11, 41)
    - 변환테이블로 사용할 객체를 미리 선언한다. (getConvertTable 함수)
      - ctoi 객체는 문자값을 키값으로 정수값을 구한다.
      - itoc 객체는 정수값을 키값으로 문자값을 구한다.

  - 암호화
    - 두번째 문자부터 암호화를 진행한다.
    - 중간중간 암호화대상이 아닌 값(문자화된 숫자, 공백, 특수문자 등)은 이전값으로 사용할 수 없기때문에 이전 문자값이 담겨있는 인덱스를 저장시킨 후 그 자리에서 다시 반복한다. (line 15-20)
    - 이전값의 위치 인덱스를 담아둔 값이 있냐 없냐에 따라 두가지 작업으로 나뉜다.
      - 이전값 인덱스 값이 -1인 경우 : 중간에 비암호화대상값이 없었다는 의미이다. 따라서 바로 현재 인덱스에서 하나 감소한 직전값을 사용한다. (line 23)
      - 이전값 인덱스 값이 -1이 아닌 경우 : 중간에 비암호화대상값이 있었다는 의미이므로, 해당 인덱스값을 사용한다. (line 25-26)
    

  - 복호화
    - 복호화 또한 두번쨰 문자부터 복호화를 진행한다.
    - 암호화와 다른점은 0번 인덱스에 두번째 문자열이 들어간다. 즉, 하나씩 자리가 앞당겨진다.
      - 즉, "HM1QA"일 경우, H는 별도로 빼고 [M,1,Q,A]가 들어있는 배열을 사용하여 값을 구한다.
      - 'H'는 result 배열에 있으며, arr에는 [M,1,Q,A]가 들어있다.
      - 결과배열에는 'H'를 미리 넣어둔 후 사용한다.
    - 중간중간 암호화대상이 아닌 값(문자화된 숫자, 공백, 특수문자 등)은 이전값으로 사용할 수 없기때문에 이전 문자값이 담겨있는 인덱스를 저장시킨 후 그 자리에서 다시 반복한다. (line 45-50)
    - 이전값의 위치 인덱스를 담아둔 값이 있냐 없냐에 따라 두가지 작업으로 나뉜다.
      - 이전값 인덱스 값이 -1인 경우 : 중간에 비암호화대상값이 없었다는 의미이다. 따라서 현재 인덱스값을 바로 사용한다. (line 53)
      - 이전값 인덱스 값이 -1이 아닌 경우 : 중간에 비암호화대상값이 있었다는 의미이므로, 해당 인덱스값을 사용한다. (line 55-56)

>변경 이력