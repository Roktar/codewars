# String subpattern recognition I - 19. 11. 04

이 문제는 입력값을 출력값의 형태로 만들어 반환한다.

- 기본 함수 (1)
  - hasSubpattern(string:문자열)
    - 결과값 출력
- 기본적으로 주어지는 객체(0)
- 문제에서 요구하는 다른 함수(0)
- 추가함수(0)
- 추가클래스(0)
- 추가객체(0)

- 입력
  <pre> "abcdabcabcd" </pre>
 
- 출력
  <pre> false </pre>

> 문제
  - 이 문제는 주어진 문자열을 사용하여 결과값을 반환한다.
  - 주어진 문자열에서 부분문자열(subpattern)을 구한 후 해당 부분문자열을 일정횟수만큼 반복했을 때 주어진 문자열과 정확히 <b><u>일치</u></b>하는지를 체크한다.

> 풀이 과정 및 결과
1) 가장 처음 생각했던 것은 해당 문자열의 모든 부분문자열을 구한 후 Set 객체로 생성하여 중복되는   부분문자열을 제거한 후 그 부분문자열이 원본문자열에서 몇 번 등장하는 지 정규식으로 구한 다음 등장횟수만큼 반복하여 원본문자열과 동일한지 체크하는 것이었다.
     - 시간초과가 떴다.

2) Set 객체를 만들지않고 부분문자열 배열을 바로 사용하여 위와 같은 방법으로 체크했다.
    - 여전히 시간초과가 떴다.

3) 부분문자열 생성 시 원분문자열 크기만큼이 아닌 원본문자열 크기의 반절까지만 부분문자열을 생성하도록 그 범위를 축소했다.
    - 원본문자열의 50%가 넘는 부분문자열은 더이상 생성할 필요가 없다고 생각하여 축소하였으나 여전히 시간초과가 떴다.

4) for문 하나를 제거하고 첫번째 for문에서 부분문자열 생성과 동시에 정규식으로 등장횟수를 체크한 후 그 횟수만큼 부분문자열을 반복한 다음 원본문자열과 동일한지 체크했다.
    - 앞의 3가지 방법보다 더 많은 테스트케이스를 통과하였으나 여전히 시간초과는 발생했으며 max buffer size도 발생했다.

5) (결과) 정규식으로 등장횟수 체크하던 것을 (원분문자열/부분문자열) 로 변경하여 체크했다.
    - 정규식을 사용하지않은 탓인지 시간초과는 더이상 뜨지 않았으며 max buffer size 또한 발생하지 않았다.
    - 현재 부분문자열의 길이가 3이고 원본 문자열의 길이가 12인 경우, 계산은 (12/3) 이 되고 결과값은 4가 나온다. 이 값을 사용하여 부분문자열을 4번 반복하여 길이 12가 된 부분문자열을 원본문자열과 비교한다.


>변경 이력
